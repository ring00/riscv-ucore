# 实验六：调度器

## 练习一

### 调度执行过程

* 关闭中断
* 将当前进程设为无需调度
* 如果当前进程处于就绪状态，则加入调度队列尾部
* 从调度队列头选出一个进程
* 运行该进程
* 使能中断

### 多级反馈队列调度算法

* 将新进程插入最高优先级队列尾部
* 进程逐渐移动到队首并被调度执行
* 若进程在限定时间内结束，则离开系统
* 若进程请求IO等阻塞操作，则被移除队列，当进程就绪时被放回队尾
* 若进程未在限定时间内结束，则将进程移入次优先的队列
* 该过程反复执行，知道进程结束或进程已到达最低优先级队列

## 练习二

### stride_init

* 初始化指向就绪进程的指针
* 初始化就绪进程数为0

### stride_enqueue

* 检查proc->run_link，保证为空
* 检查rq->lab6_run_pool是否为NULL
    * 若为NULL，则初始化proc->run_link，并将rq->lab6_run_pool指向它
    * 否则，调用skew_heap_insert将其插入斜堆
* 若进程已无时间片或者时间片数大于允许的最大值，则将其设为rq->max_time_slice
* 将proc->rq指向rq
* 就绪数加1

### stride_dequeue

* 检查`proc->rq == rq && rq->proc_num > 0`
* 调用skew_heap_remove将进程移出队列
* 就绪进程数减1

### stride_pick_next

* 直接选择堆顶的进程
* 将该进程的stride加上BIG_STRIDE除以优先级

## 总结

### 实现与参考答案的区别

实现逻辑基本相同

### 知识点

* 进程调度算法
* 进程切换过程
